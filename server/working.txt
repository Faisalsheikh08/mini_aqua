// import { Document, Paragraph, TextRun, AlignmentType, HeadingLevel, Table, TableRow, TableCell, WidthType, BorderStyle } from "docx";
// import { Question } from "../shared/schema";
// import { parse } from "node-html-parser";

// // Enhanced function to decode HTML entities with comprehensive coverage
// function decodeHtmlEntities(content: string): string {
//   if (!content) return "";
  
//   return content
//     // First handle double-encoded entities (common issue)
//     .replace(/&amp;quot;/g, '"')
//     .replace(/&amp;amp;/g, '&')
//     .replace(/&amp;lt;/g, '<')
//     .replace(/&amp;gt;/g, '>')
//     .replace(/&amp;nbsp;/g, ' ')
    
//     // Standard HTML entities
//     .replace(/&lt;/g, '<')
//     .replace(/&gt;/g, '>')
//     .replace(/&quot;/g, '"')
//     .replace(/&#39;/g, "'")
//     .replace(/&apos;/g, "'")
//     .replace(/&nbsp;/g, ' ')
    
//     // Extended Latin characters (Spanish, French, German, etc.)
//     .replace(/&aacute;/g, 'á')
//     .replace(/&Aacute;/g, 'Á')
//     .replace(/&eacute;/g, 'é')
//     .replace(/&Eacute;/g, 'É')
//     .replace(/&iacute;/g, 'í')
//     .replace(/&Iacute;/g, 'Í')
//     .replace(/&oacute;/g, 'ó')
//     .replace(/&Oacute;/g, 'Ó')
//     .replace(/&uacute;/g, 'ú')
//     .replace(/&Uacute;/g, 'Ú')
//     .replace(/&ntilde;/g, 'ñ')
//     .replace(/&Ntilde;/g, 'Ñ')
    
//     // Mathematical fractions (HTML entities)
//     .replace(/&frac14;/g, '¼')
//     .replace(/&frac12;/g, '½')
//     .replace(/&frac34;/g, '¾')
//     .replace(/&frac13;/g, '⅓')
//     .replace(/&frac23;/g, '⅔')
//     .replace(/&frac15;/g, '⅕')
//     .replace(/&frac25;/g, '⅖')
//     .replace(/&frac35;/g, '⅗')
//     .replace(/&frac45;/g, '⅘')
//     .replace(/&frac16;/g, '⅙')
//     .replace(/&frac56;/g, '⅚')
//     .replace(/&frac18;/g, '⅛')
//     .replace(/&frac38;/g, '⅜')
//     .replace(/&frac58;/g, '⅝')
//     .replace(/&frac78;/g, '⅞')
//     .replace(/&agrave;/g, 'à')
//     .replace(/&Agrave;/g, 'À')
//     .replace(/&egrave;/g, 'è')
//     .replace(/&Egrave;/g, 'È')
//     .replace(/&igrave;/g, 'ì')
//     .replace(/&Igrave;/g, 'Ì')
//     .replace(/&ograve;/g, 'ò')
//     .replace(/&Ograve;/g, 'Ò')
//     .replace(/&ugrave;/g, 'ù')
//     .replace(/&Ugrave;/g, 'Ù')
//     .replace(/&acirc;/g, 'â')
//     .replace(/&Acirc;/g, 'Â')
//     .replace(/&ecirc;/g, 'ê')
//     .replace(/&Ecirc;/g, 'Ê')
//     .replace(/&icirc;/g, 'î')
//     .replace(/&Icirc;/g, 'Î')
//     .replace(/&ocirc;/g, 'ô')
//     .replace(/&Ocirc;/g, 'Ô')
//     .replace(/&ucirc;/g, 'û')
//     .replace(/&Ucirc;/g, 'Û')
//     .replace(/&auml;/g, 'ä')
//     .replace(/&Auml;/g, 'Ä')
//     .replace(/&euml;/g, 'ë')
//     .replace(/&Euml;/g, 'Ë')
//     .replace(/&iuml;/g, 'ï')
//     .replace(/&Iuml;/g, 'Ï')
//     .replace(/&ouml;/g, 'ö')
//     .replace(/&Ouml;/g, 'Ö')
//     .replace(/&uuml;/g, 'ü')
//     .replace(/&Uuml;/g, 'Ü')
//     .replace(/&yuml;/g, 'ÿ')
//     .replace(/&ccedil;/g, 'ç')
//     .replace(/&Ccedil;/g, 'Ç')
    
//     // Typographic quotes and dashes
//     .replace(/&ldquo;/g, '"')
//     .replace(/&rdquo;/g, '"')
//     .replace(/&lsquo;/g, "'")
//     .replace(/&rsquo;/g, "'")
//     .replace(/&mdash;/g, '—')
//     .replace(/&ndash;/g, '–')
//     .replace(/&hellip;/g, '...')
//     .replace(/&ensp;/g, ' ')
//     .replace(/&emsp;/g, '  ')
//     .replace(/&thinsp;/g, ' ')
    
//     // Unicode text formatting controls (Hindi/Devanagari specific)
//     .replace(/&zwj;/g, '\u200D')
//     .replace(/&zwnj;/g, '\u200C')
//     .replace(/&lrm;/g, '\u200E')
//     .replace(/&rlm;/g, '\u200F')
//     .replace(/&shy;/g, '\u00AD')
    
//     // Symbols
//     .replace(/&copy;/g, '©')
//     .replace(/&reg;/g, '®')
//     .replace(/&trade;/g, '™')
//     .replace(/&deg;/g, '°')
//     .replace(/&sect;/g, '§')
//     .replace(/&para;/g, '¶')
//     .replace(/&middot;/g, '·')
//     .replace(/&bull;/g, '•')
//     .replace(/&dagger;/g, '†')
//     .replace(/&Dagger;/g, '‡')
    
//     // Handle specific problematic numeric entities first
//     .replace(/&#39;/g, "'")
//     .replace(/&#34;/g, '"')
//     .replace(/&#38;/g, '&')
//     .replace(/&#60;/g, '<')
//     .replace(/&#62;/g, '>')
//     .replace(/&#32;/g, ' ')
//     .replace(/&#160;/g, ' ')
//     .replace(/&#8217;/g, "'")
//     .replace(/&#8216;/g, "'")
//     .replace(/&#8220;/g, '"')
//     .replace(/&#8221;/g, '"')
//     .replace(/&#8211;/g, '–')
//     .replace(/&#8212;/g, '—')
//     .replace(/&#8230;/g, '...')
    
//     // Handle general numeric entities (decimal)
//     .replace(/&#(\d+);/g, (match, code) => {
//       try {
//         const charCode = parseInt(code, 10);
//         if (charCode > 0 && charCode < 1114112) {
//           return String.fromCharCode(charCode);
//         }
//         return '';
//       } catch {
//         return '';
//       }
//     })
    
//     // Handle hexadecimal entities
//     .replace(/&#x([a-fA-F0-9]+);/g, (match, code) => {
//       try {
//         const charCode = parseInt(code, 16);
//         if (charCode > 0 && charCode < 1114112) {
//           return String.fromCharCode(charCode);
//         }
//         return '';
//       } catch {
//         return '';
//       }
//     })
    
//     // Keep ampersand LAST to avoid double-decoding
//     .replace(/&amp;/g, '&');
// }

// // Function to render LaTeX math to Unicode
// function renderLatexMath(text: string): string {
//   return text
//     .replace(/\\\(\s*(\d+)\s+\\frac\{1\}\{2\}\s*\\\)/g, '$1½')
//     .replace(/\\\(\s*(\d+)\s+\\frac\{1\}\{4\}\s*\\\)/g, '$1¼')
//     .replace(/\\\(\s*(\d+)\s+\\frac\{3\}\{4\}\s*\\\)/g, '$1¾')
//     .replace(/\\\(\s*(\d+)\\frac\{1\}\{2\}\s*\\\)/g, '$1½')
//     .replace(/\\\(\s*(\d+)\\frac\{1\}\{4\}\s*\\\)/g, '$1¼')
//     .replace(/\\\(\s*(\d+)\\frac\{3\}\{4\}\s*\\\)/g, '$1¾')
//     .replace(/\\\(\s*\\frac\{1\}\{2\}\s*\\\)/g, '½')
//     .replace(/\\\(\s*\\frac\{1\}\{4\}\s*\\\)/g, '¼')
//     .replace(/\\\(\s*\\frac\{3\}\{4\}\s*\\\)/g, '¾')
//     .replace(/\\\(\s*\\frac\{1\}\{3\}\s*\\\)/g, '⅓')
//     .replace(/\\\(\s*\\frac\{2\}\{3\}\s*\\\)/g, '⅔')
//     .replace(/\\\(\s*\\frac\{1\}\{5\}\s*\\\)/g, '⅕')
//     .replace(/\\\(\s*\\frac\{2\}\{5\}\s*\\\)/g, '⅖')
//     .replace(/\\\(\s*\\frac\{3\}\{5\}\s*\\\)/g, '⅗')
//     .replace(/\\\(\s*\\frac\{4\}\{5\}\s*\\\)/g, '⅘')
//     .replace(/\\\(\s*\\frac\{1\}\{6\}\s*\\\)/g, '⅙')
//     .replace(/\\\(\s*\\frac\{5\}\{6\}\s*\\\)/g, '⅚')
//     .replace(/\\\(\s*\\frac\{1\}\{8\}\s*\\\)/g, '⅛')
//     .replace(/\\\(\s*\\frac\{3\}\{8\}\s*\\\)/g, '⅜')
//     .replace(/\\\(\s*\\frac\{5\}\{8\}\s*\\\)/g, '⅝')
//     .replace(/\\\(\s*\\frac\{7\}\{8\}\s*\\\)/g, '⅞')
//     .replace(/\\\(\s*\\frac\{([^}]+)\}\{([^}]+)\}\s*\\\)/g, '($1/$2)')
//     .replace(/\\\(/g, '').replace(/\\\)/g, '')
//     .replace(/\\\[/g, '').replace(/\\\]/g, '');
// }

// // NEW: Function to process bilingual text inline (keep on same line with " / ")
// function processBilingualTextInline(content: string): string {
//   if (!content) return "";
  
//   let decoded = decodeHtmlEntities(content);
//   decoded = decoded.replace(/^<br\/?>\s*/gi, '').trim();
  
//   // Check for existing <br/>[Hindi] or <br>[Hindi] format - convert to " / "
//   const brHindiMatch = decoded.match(/^(.*?)<br\/?>\s*\[Hindi\]\s*(.*)$/s);
//   if (brHindiMatch) {
//     const englishPart = renderLatexMath(brHindiMatch[1].trim());
//     const hindiPart = renderLatexMath(brHindiMatch[2].trim());
//     return `${englishPart} / ${hindiPart}`;
//   }

//   // Check for standalone [Hindi] marker
//   const standaloneHindiMatch = decoded.match(/^(.*?)\[Hindi\]\s*(.*)$/s);
//   if (standaloneHindiMatch && decoded.includes('[Hindi]')) {
//     const beforeHindi = standaloneHindiMatch[1].trim();
//     let afterHindi = standaloneHindiMatch[2].replace(/^\[Hindi\]\s*/, '').trim();
//     afterHindi = afterHindi.replace(/\[Hindi\]/g, '').trim();
    
//     const englishPart = renderLatexMath(beforeHindi);
//     const hindiPart = renderLatexMath(afterHindi);
//     return `${englishPart} / ${hindiPart}`;
//   }
  
//   // Check for original " / " format - already in correct format
//   if (decoded.includes(' / ')) {
//     return renderLatexMath(decoded);
//   }
  
//   // Single language
//   return renderLatexMath(decoded);
// }

// // NEW: Function to process solution text with proper headers
// function processSolutionText(content: string): { english: string, hindi?: string } {
//   if (!content) return { english: "" };
  
//   let decoded = decodeHtmlEntities(content);
//   decoded = decoded.replace(/^<br\/?>\s*/gi, '').trim();
  
//   // Check for existing <br/>[Hindi] format
//   const brHindiMatch = decoded.match(/^(.*?)<br\/?>\s*\[Hindi\]\s*(.*)$/s);
//   if (brHindiMatch) {
//     const englishPart = renderLatexMath(brHindiMatch[1].trim());
//     const hindiPart = renderLatexMath(brHindiMatch[2].trim());
//     return { english: englishPart, hindi: hindiPart };
//   }

//   // Check for standalone [Hindi] marker
//   const standaloneHindiMatch = decoded.match(/^(.*?)\[Hindi\]\s*(.*)$/s);
//   if (standaloneHindiMatch && decoded.includes('[Hindi]')) {
//     const beforeHindi = standaloneHindiMatch[1].trim();
//     let afterHindi = standaloneHindiMatch[2].replace(/^\[Hindi\]\s*/, '').trim();
//     afterHindi = afterHindi.replace(/\[Hindi\]/g, '').trim();
    
//     const englishPart = renderLatexMath(beforeHindi);
//     const hindiPart = renderLatexMath(afterHindi);
//     return { english: englishPart, hindi: hindiPart };
//   }
  
//   // Check for " / " separator
//   const slashMatch = decoded.match(/^(.*?)\s+\/\s+(.*)$/s);
//   if (slashMatch) {
//     const englishPart = renderLatexMath(slashMatch[1].trim());
//     const hindiPart = renderLatexMath(slashMatch[2].trim());
//     return { english: englishPart, hindi: hindiPart };
//   }
  
//   // Single language
//   return { english: renderLatexMath(decoded) };
// }

// // Enhanced HTML cleaning
// function cleanHtmlContent(content: string): string {
//   if (!content) return "";
  
//   const decoded = decodeHtmlEntities(content);
  
//   let cleaned = decoded
//     .replace(/^<br\/?>\s*/gi, '')
//     .trim();
  
//   let spaced = cleaned
//     .replace(/<\/(b|strong|i|em|u|span)>/gi, ' ')
//     .replace(/<(b|strong|i|em|u|span)[^>]*>/gi, ' ')
//     .replace(/<\/?(br|p|div)[^>]*>/gi, ' ')
//     .replace(/<[^>]*>/g, '')
//     .replace(/\s+/g, ' ')
//     .trim();
  
//   return spaced;
// }

// // Function to create a Word document from questions
// export function createWordDocument(questions: Question[], testName: string): Document {
//   const paragraphs: (Paragraph | Table)[] = [];
  
//   // Add title
//   paragraphs.push(
//     new Paragraph({
//       text: testName || "Question Bank Export",
//       heading: HeadingLevel.TITLE,
//       alignment: AlignmentType.CENTER,
//       spacing: { after: 400 }
//     })
//   );
  
//   // Add questions
//   questions.forEach((question, index) => {
//     const questionNumber = index + 1;
    
//     // Question text - keep bilingual on same line
//     const questionText = processBilingualTextInline(question.question);
    
//     paragraphs.push(
//       new Paragraph({
//         children: [
//           new TextRun({
//             text: `${questionNumber}. ${cleanHtmlContent(questionText)}`,
//             bold: true,
//             size: 24
//           })
//         ],
//         spacing: { before: 200, after: 100 }
//       })
//     );
    
//     // Options (A, B, C, D, E) - keep bilingual on same line
//     const options = [
//       { label: 'A', text: question.option1 },
//       { label: 'B', text: question.option2 },
//       { label: 'C', text: question.option3 },
//       { label: 'D', text: question.option4 },
//       { label: 'E', text: question.option5 }
//     ];
    
//     options.forEach(option => {
//       if (option.text && option.text.trim()) {
//         const optionText = processBilingualTextInline(option.text);
        
//         paragraphs.push(
//           new Paragraph({
//             children: [
//               new TextRun({
//                 text: `${option.label}. ${cleanHtmlContent(optionText)}`,
//                 size: 22
//               })
//             ],
//             spacing: { before: 50, after: 50 },
//             indent: { left: 400 }
//           })
//         );
//       }
//     });
    
//     // Answer
//     if (question.answer) {
//       const answerLetter = ['A', 'B', 'C', 'D', 'E'][question.answer - 1] || question.answer.toString();
//       paragraphs.push(
//         new Paragraph({
//           children: [
//             new TextRun({
//               text: "Answer ",
//               bold: false,
//               size: 22
//             }),
//             new TextRun({
//               text: answerLetter,
//               bold: true,
//               size: 22,
//               color: "008000"
//             })
//           ],
//           spacing: { before: 100, after: 100 }
//         })
//       );
//     }
    
//     // Solution section with proper headers
//     if (question.description && question.description.trim()) {
//       const solutionContent = processSolutionText(question.description);
      
//       paragraphs.push(
//         new Paragraph({
//           children: [
//             new TextRun({
//               text: "Solution.",
//               bold: false,
//               size: 22,
//               color: "8B4513"
//             })
//           ],
//           spacing: { before: 150, after: 50 }
//         })
//       );
      
//       // English Solution with header
//       if (solutionContent.english) {
//         paragraphs.push(
//           new Paragraph({
//             children: [
//               new TextRun({
//                 text: "English Solution:",
//                 bold: true,
//                 size: 22
//               })
//             ],
//             spacing: { before: 100, after: 50 }
//           })
//         );
        
//         paragraphs.push(
//           new Paragraph({
//             children: [
//               new TextRun({
//                 text: cleanHtmlContent(solutionContent.english),
//                 size: 22
//               })
//             ],
//             spacing: { after: 100 }
//           })
//         );
//       }
      
//       // Hindi Solution with header (if exists)
//       if (solutionContent.hindi) {
//         paragraphs.push(
//           new Paragraph({
//             children: [
//               new TextRun({
//                 text: "Hindi Solution",
//                 bold: true,
//                 size: 22
//               })
//             ],
//             spacing: { before: 100, after: 50 }
//           })
//         );
        
//         paragraphs.push(
//           new Paragraph({
//             children: [
//               new TextRun({
//                 text: cleanHtmlContent(solutionContent.hindi),
//                 size: 22
//               })
//             ],
//             spacing: { after: 100 }
//           })
//         );
//       }
//     }
    
//     // Add spacing between questions
//     paragraphs.push(
//       new Paragraph({
//         text: "",
//         spacing: { after: 400 }
//       })
//     );
//   });
  
//   return new Document({
//     sections: [{
//       properties: {},
//       children: paragraphs,
//     }],
//   });
// }


import { Document, Paragraph, TextRun, AlignmentType, HeadingLevel, Table, TableRow, TableCell, WidthType, BorderStyle } from "docx";
import { Question } from "../shared/schema";
import { parse } from "node-html-parser";

// Enhanced function to decode HTML entities with comprehensive coverage
function decodeHtmlEntities(content: string): string {
  if (!content) return "";
  
  return content
    // First handle double-encoded entities (common issue)
    .replace(/&amp;quot;/g, '"')
    .replace(/&amp;amp;/g, '&')
    .replace(/&amp;lt;/g, '<')
    .replace(/&amp;gt;/g, '>')
    .replace(/&amp;nbsp;/g, ' ')
    
    // Standard HTML entities
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&nbsp;/g, ' ')
    
    // Extended Latin characters (Spanish, French, German, etc.)
    .replace(/&aacute;/g, 'á')
    .replace(/&Aacute;/g, 'Á')
    .replace(/&eacute;/g, 'é')
    .replace(/&Eacute;/g, 'É')
    .replace(/&iacute;/g, 'í')
    .replace(/&Iacute;/g, 'Í')
    .replace(/&oacute;/g, 'ó')
    .replace(/&Oacute;/g, 'Ó')
    .replace(/&uacute;/g, 'ú')
    .replace(/&Uacute;/g, 'Ú')
    .replace(/&ntilde;/g, 'ñ')
    .replace(/&Ntilde;/g, 'Ñ')
    
    // Mathematical fractions (HTML entities)
    .replace(/&frac14;/g, '¼')
    .replace(/&frac12;/g, '½')
    .replace(/&frac34;/g, '¾')
    .replace(/&frac13;/g, '⅓')
    .replace(/&frac23;/g, '⅔')
    .replace(/&frac15;/g, '⅕')
    .replace(/&frac25;/g, '⅖')
    .replace(/&frac35;/g, '⅗')
    .replace(/&frac45;/g, '⅘')
    .replace(/&frac16;/g, '⅙')
    .replace(/&frac56;/g, '⅚')
    .replace(/&frac18;/g, '⅛')
    .replace(/&frac38;/g, '⅜')
    .replace(/&frac58;/g, '⅝')
    .replace(/&frac78;/g, '⅞')
    .replace(/&agrave;/g, 'à')
    .replace(/&Agrave;/g, 'À')
    .replace(/&egrave;/g, 'è')
    .replace(/&Egrave;/g, 'È')
    .replace(/&igrave;/g, 'ì')
    .replace(/&Igrave;/g, 'Ì')
    .replace(/&ograve;/g, 'ò')
    .replace(/&Ograve;/g, 'Ò')
    .replace(/&ugrave;/g, 'ù')
    .replace(/&Ugrave;/g, 'Ù')
    .replace(/&acirc;/g, 'â')
    .replace(/&Acirc;/g, 'Â')
    .replace(/&ecirc;/g, 'ê')
    .replace(/&Ecirc;/g, 'Ê')
    .replace(/&icirc;/g, 'î')
    .replace(/&Icirc;/g, 'Î')
    .replace(/&ocirc;/g, 'ô')
    .replace(/&Ocirc;/g, 'Ô')
    .replace(/&ucirc;/g, 'û')
    .replace(/&Ucirc;/g, 'Û')
    .replace(/&auml;/g, 'ä')
    .replace(/&Auml;/g, 'Ä')
    .replace(/&euml;/g, 'ë')
    .replace(/&Euml;/g, 'Ë')
    .replace(/&iuml;/g, 'ï')
    .replace(/&Iuml;/g, 'Ï')
    .replace(/&ouml;/g, 'ö')
    .replace(/&Ouml;/g, 'Ö')
    .replace(/&uuml;/g, 'ü')
    .replace(/&Uuml;/g, 'Ü')
    .replace(/&yuml;/g, 'ÿ')
    .replace(/&ccedil;/g, 'ç')
    .replace(/&Ccedil;/g, 'Ç')
    
    // Typographic quotes and dashes
    .replace(/&ldquo;/g, '"')
    .replace(/&rdquo;/g, '"')
    .replace(/&lsquo;/g, "'")
    .replace(/&rsquo;/g, "'")
    .replace(/&mdash;/g, '—')
    .replace(/&ndash;/g, '–')
    .replace(/&hellip;/g, '...')
    .replace(/&ensp;/g, ' ')
    .replace(/&emsp;/g, '  ')
    .replace(/&thinsp;/g, ' ')
    
    // Unicode text formatting controls (Hindi/Devanagari specific)
    .replace(/&zwj;/g, '\u200D')
    .replace(/&zwnj;/g, '\u200C')
    .replace(/&lrm;/g, '\u200E')
    .replace(/&rlm;/g, '\u200F')
    .replace(/&shy;/g, '\u00AD')
    
    // Symbols
    .replace(/&copy;/g, '©')
    .replace(/&reg;/g, '®')
    .replace(/&trade;/g, '™')
    .replace(/&deg;/g, '°')
    .replace(/&sect;/g, '§')
    .replace(/&para;/g, '¶')
    .replace(/&middot;/g, '·')
    .replace(/&bull;/g, '•')
    .replace(/&dagger;/g, '†')
    .replace(/&Dagger;/g, '‡')
    
    // Handle specific problematic numeric entities first
    .replace(/&#39;/g, "'")
    .replace(/&#34;/g, '"')
    .replace(/&#38;/g, '&')
    .replace(/&#60;/g, '<')
    .replace(/&#62;/g, '>')
    .replace(/&#32;/g, ' ')
    .replace(/&#160;/g, ' ')
    .replace(/&#8217;/g, "'")
    .replace(/&#8216;/g, "'")
    .replace(/&#8220;/g, '"')
    .replace(/&#8221;/g, '"')
    .replace(/&#8211;/g, '–')
    .replace(/&#8212;/g, '—')
    .replace(/&#8230;/g, '...')
    
    // Handle general numeric entities (decimal)
    .replace(/&#(\d+);/g, (match, code) => {
      try {
        const charCode = parseInt(code, 10);
        if (charCode > 0 && charCode < 1114112) {
          return String.fromCharCode(charCode);
        }
        return '';
      } catch {
        return '';
      }
    })
    
    // Handle hexadecimal entities
    .replace(/&#x([a-fA-F0-9]+);/g, (match, code) => {
      try {
        const charCode = parseInt(code, 16);
        if (charCode > 0 && charCode < 1114112) {
          return String.fromCharCode(charCode);
        }
        return '';
      } catch {
        return '';
      }
    })
    
    // Keep ampersand LAST to avoid double-decoding
    .replace(/&amp;/g, '&');
}

// Function to render LaTeX math to Unicode
function renderLatexMath(text: string): string {
  return text
    .replace(/\\\(\s*(\d+)\s+\\frac\{1\}\{2\}\s*\\\)/g, '$1½')
    .replace(/\\\(\s*(\d+)\s+\\frac\{1\}\{4\}\s*\\\)/g, '$1¼')
    .replace(/\\\(\s*(\d+)\s+\\frac\{3\}\{4\}\s*\\\)/g, '$1¾')
    .replace(/\\\(\s*(\d+)\\frac\{1\}\{2\}\s*\\\)/g, '$1½')
    .replace(/\\\(\s*(\d+)\\frac\{1\}\{4\}\s*\\\)/g, '$1¼')
    .replace(/\\\(\s*(\d+)\\frac\{3\}\{4\}\s*\\\)/g, '$1¾')
    .replace(/\\\(\s*\\frac\{1\}\{2\}\s*\\\)/g, '½')
    .replace(/\\\(\s*\\frac\{1\}\{4\}\s*\\\)/g, '¼')
    .replace(/\\\(\s*\\frac\{3\}\{4\}\s*\\\)/g, '¾')
    .replace(/\\\(\s*\\frac\{1\}\{3\}\s*\\\)/g, '⅓')
    .replace(/\\\(\s*\\frac\{2\}\{3\}\s*\\\)/g, '⅔')
    .replace(/\\\(\s*\\frac\{1\}\{5\}\s*\\\)/g, '⅕')
    .replace(/\\\(\s*\\frac\{2\}\{5\}\s*\\\)/g, '⅖')
    .replace(/\\\(\s*\\frac\{3\}\{5\}\s*\\\)/g, '⅗')
    .replace(/\\\(\s*\\frac\{4\}\{5\}\s*\\\)/g, '⅘')
    .replace(/\\\(\s*\\frac\{1\}\{6\}\s*\\\)/g, '⅙')
    .replace(/\\\(\s*\\frac\{5\}\{6\}\s*\\\)/g, '⅚')
    .replace(/\\\(\s*\\frac\{1\}\{8\}\s*\\\)/g, '⅛')
    .replace(/\\\(\s*\\frac\{3\}\{8\}\s*\\\)/g, '⅜')
    .replace(/\\\(\s*\\frac\{5\}\{8\}\s*\\\)/g, '⅝')
    .replace(/\\\(\s*\\frac\{7\}\{8\}\s*\\\)/g, '⅞')
    .replace(/\\\(\s*\\frac\{([^}]+)\}\{([^}]+)\}\s*\\\)/g, '($1/$2)')
    .replace(/\\\(/g, '').replace(/\\\)/g, '')
    .replace(/\\\[/g, '').replace(/\\\]/g, '');
}

// NEW: Function to process bilingual text inline (keep on same line with " / ")
function processBilingualTextInline(content: string): string {
  if (!content) return "";
  
  let decoded = decodeHtmlEntities(content);
  decoded = decoded.replace(/^<br\/?>\s*/gi, '').trim();
  
  // Check for existing <br/>[Hindi] or <br>[Hindi] format - convert to " / "
  const brHindiMatch = decoded.match(/^(.*?)<br\/?>\s*\[Hindi\]\s*(.*)$/s);
  if (brHindiMatch) {
    const englishPart = renderLatexMath(brHindiMatch[1].trim());
    const hindiPart = renderLatexMath(brHindiMatch[2].trim());
    return `${englishPart} / ${hindiPart}`;
  }

  // Check for standalone [Hindi] marker
  const standaloneHindiMatch = decoded.match(/^(.*?)\[Hindi\]\s*(.*)$/s);
  if (standaloneHindiMatch && decoded.includes('[Hindi]')) {
    const beforeHindi = standaloneHindiMatch[1].trim();
    let afterHindi = standaloneHindiMatch[2].replace(/^\[Hindi\]\s*/, '').trim();
    afterHindi = afterHindi.replace(/\[Hindi\]/g, '').trim();
    
    const englishPart = renderLatexMath(beforeHindi);
    const hindiPart = renderLatexMath(afterHindi);
    return `${englishPart} / ${hindiPart}`;
  }
  
  // Check for original " / " format - already in correct format
  if (decoded.includes(' / ')) {
    return renderLatexMath(decoded);
  }
  
  // Single language
  return renderLatexMath(decoded);
}

// NEW: Function to process solution text with proper headers
function processSolutionText(content: string): { english: string, hindi?: string } {
  if (!content) return { english: "" };
  
  let decoded = decodeHtmlEntities(content);
  decoded = decoded.replace(/^<br\/?>\s*/gi, '').trim();
  
  // Check for existing <br/>[Hindi] format
  const brHindiMatch = decoded.match(/^(.*?)<br\/?>\s*\[Hindi\]\s*(.*)$/s);
  if (brHindiMatch) {
    const englishPart = renderLatexMath(brHindiMatch[1].trim());
    const hindiPart = renderLatexMath(brHindiMatch[2].trim());
    return { english: englishPart, hindi: hindiPart };
  }

  // Check for standalone [Hindi] marker
  const standaloneHindiMatch = decoded.match(/^(.*?)\[Hindi\]\s*(.*)$/s);
  if (standaloneHindiMatch && decoded.includes('[Hindi]')) {
    const beforeHindi = standaloneHindiMatch[1].trim();
    let afterHindi = standaloneHindiMatch[2].replace(/^\[Hindi\]\s*/, '').trim();
    afterHindi = afterHindi.replace(/\[Hindi\]/g, '').trim();
    
    const englishPart = renderLatexMath(beforeHindi);
    const hindiPart = renderLatexMath(afterHindi);
    return { english: englishPart, hindi: hindiPart };
  }
  
  // Check for " / " separator
  const slashMatch = decoded.match(/^(.*?)\s+\/\s+(.*)$/s);
  if (slashMatch) {
    const englishPart = renderLatexMath(slashMatch[1].trim());
    const hindiPart = renderLatexMath(slashMatch[2].trim());
    return { english: englishPart, hindi: hindiPart };
  }
  
  // Single language
  return { english: renderLatexMath(decoded) };
}

// Enhanced HTML cleaning
function cleanHtmlContent(content: string): string {
  if (!content) return "";
  
  const decoded = decodeHtmlEntities(content);
  
  let cleaned = decoded
    .replace(/^<br\/?>\s*/gi, '')
    .trim();
  
  let spaced = cleaned
    .replace(/<\/(b|strong|i|em|u|span)>/gi, ' ')
    .replace(/<(b|strong|i|em|u|span)[^>]*>/gi, ' ')
    .replace(/<\/?(br|p|div)[^>]*>/gi, ' ')
    .replace(/<[^>]*>/g, '')
    .replace(/\s+/g, ' ')
    .trim();
  
  return spaced;
}

// Function to create a Word document from questions
export function createWordDocument(questions: Question[], testName: string): Document {
  const paragraphs: (Paragraph | Table)[] = [];

  // Add title
  paragraphs.push(
    new Paragraph({
      text: testName || "Question Bank Export",
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    })
  );

  // Add questions
  questions.forEach((question, index) => {
    const questionNumber = index + 1;

    // Question text - bilingual on same line, no HTML
    const questionText = cleanHtmlContent(processBilingualTextInline(question.question));
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `${questionNumber}. ${questionText}`,
            bold: true,
            size: 24
          })
        ],
        spacing: { before: 200, after: 100 }
      })
    );

    // Options (A, B, C, D, E) - bilingual on same line, no HTML
    const options = [
      { label: 'A', text: question.option1 },
      { label: 'B', text: question.option2 },
      { label: 'C', text: question.option3 },
      { label: 'D', text: question.option4 },
      { label: 'E', text: question.option5 }
    ];

    options.forEach(option => {
      if (option.text && option.text.trim()) {
        const optionText = cleanHtmlContent(processBilingualTextInline(option.text));
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `${option.label}. ${optionText}`,
                size: 22
              })
            ],
            spacing: { before: 50, after: 50 },
            indent: { left: 400 }
          })
        );
      }
    });

    // Answer
    if (question.answer) {
      const answerLetter = ['A', 'B', 'C', 'D', 'E'][question.answer - 1] || question.answer.toString();
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: "Answer ",
              bold: false,
              size: 22
            }),
            new TextRun({
              text: answerLetter,
              bold: true,
              size: 22,
              color: "008000"
            })
          ],
          spacing: { before: 100, after: 100 }
        })
      );
    }

    // Solution section: Hindi and English as separate paragraphs, no headers, no HTML
    if (question.description && question.description.trim()) {
      const solutionContent = processSolutionText(question.description);

      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: "Solution.",
              bold: false,
              size: 22,
              color: "8B4513"
            })
          ],
          spacing: { before: 150, after: 50 }
        })
      );

      // Hindi solution first (if exists)
      if (solutionContent.hindi) {
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: cleanHtmlContent(solutionContent.hindi),
                size: 22
              })
            ],
            spacing: { after: 100 }
          })
        );
      }

      // English solution (if exists)
      if (solutionContent.english) {
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: cleanHtmlContent(solutionContent.english),
                size: 22
              })
            ],
            spacing: { after: 100 }
          })
        );
      }
    }

    // Add spacing between questions
    paragraphs.push(
      new Paragraph({
        text: "",
        spacing: { after: 400 }
      })
    );
  });

  return new Document({
    sections: [{
      properties: {},
      children: paragraphs,
    }],
  });
}
















































import {
  Document,
  Paragraph,
  TextRun,
  AlignmentType,
  HeadingLevel,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle,
} from "docx";
import { Question } from "../shared/schema";
import { parse } from "node-html-parser";

// Enhanced function to decode HTML entities with comprehensive coverage
function decodeHtmlEntities(content: string): string {
  if (!content) return "";

  return (
    content
      // First handle double-encoded entities (common issue)
      .replace(/&amp;quot;/g, '"')
      .replace(/&amp;amp;/g, "&")
      .replace(/&amp;lt;/g, "<")
      .replace(/&amp;gt;/g, ">")
      .replace(/&amp;nbsp;/g, " ")

      // Standard HTML entities
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&apos;/g, "'")
      .replace(/&nbsp;/g, " ")

      // Extended Latin characters (Spanish, French, German, etc.)
      .replace(/&aacute;/g, "á")
      .replace(/&Aacute;/g, "Á")
      .replace(/&eacute;/g, "é")
      .replace(/&Eacute;/g, "É")
      .replace(/&iacute;/g, "í")
      .replace(/&Iacute;/g, "Í")
      .replace(/&oacute;/g, "ó")
      .replace(/&Oacute;/g, "Ó")
      .replace(/&uacute;/g, "ú")
      .replace(/&Uacute;/g, "Ú")
      .replace(/&ntilde;/g, "ñ")
      .replace(/&Ntilde;/g, "Ñ")

      // Mathematical fractions (HTML entities)
      .replace(/&frac14;/g, "¼")
      .replace(/&frac12;/g, "½")
      .replace(/&frac34;/g, "¾")
      .replace(/&frac13;/g, "⅓")
      .replace(/&frac23;/g, "⅔")
      .replace(/&frac15;/g, "⅕")
      .replace(/&frac25;/g, "⅖")
      .replace(/&frac35;/g, "⅗")
      .replace(/&frac45;/g, "⅘")
      .replace(/&frac16;/g, "⅙")
      .replace(/&frac56;/g, "⅚")
      .replace(/&frac18;/g, "⅛")
      .replace(/&frac38;/g, "⅜")
      .replace(/&frac58;/g, "⅝")
      .replace(/&frac78;/g, "⅞")
      .replace(/&agrave;/g, "à")
      .replace(/&Agrave;/g, "À")
      .replace(/&egrave;/g, "è")
      .replace(/&Egrave;/g, "È")
      .replace(/&igrave;/g, "ì")
      .replace(/&Igrave;/g, "Ì")
      .replace(/&ograve;/g, "ò")
      .replace(/&Ograve;/g, "Ò")
      .replace(/&ugrave;/g, "ù")
      .replace(/&Ugrave;/g, "Ù")
      .replace(/&acirc;/g, "â")
      .replace(/&Acirc;/g, "Â")
      .replace(/&ecirc;/g, "ê")
      .replace(/&Ecirc;/g, "Ê")
      .replace(/&icirc;/g, "î")
      .replace(/&Icirc;/g, "Î")
      .replace(/&ocirc;/g, "ô")
      .replace(/&Ocirc;/g, "Ô")
      .replace(/&ucirc;/g, "û")
      .replace(/&Ucirc;/g, "Û")
      .replace(/&auml;/g, "ä")
      .replace(/&Auml;/g, "Ä")
      .replace(/&euml;/g, "ë")
      .replace(/&Euml;/g, "Ë")
      .replace(/&iuml;/g, "ï")
      .replace(/&Iuml;/g, "Ï")
      .replace(/&ouml;/g, "ö")
      .replace(/&Ouml;/g, "Ö")
      .replace(/&uuml;/g, "ü")
      .replace(/&Uuml;/g, "Ü")
      .replace(/&yuml;/g, "ÿ")
      .replace(/&ccedil;/g, "ç")
      .replace(/&Ccedil;/g, "Ç")

      // Typographic quotes and dashes
      .replace(/&ldquo;/g, '"')
      .replace(/&rdquo;/g, '"')
      .replace(/&lsquo;/g, "'")
      .replace(/&rsquo;/g, "'")
      .replace(/&mdash;/g, "—")
      .replace(/&ndash;/g, "–")
      .replace(/&hellip;/g, "...")
      .replace(/&ensp;/g, " ")
      .replace(/&emsp;/g, "  ")
      .replace(/&thinsp;/g, " ")

      // Unicode text formatting controls (Hindi/Devanagari specific)
      .replace(/&zwj;/g, "\u200D")
      .replace(/&zwnj;/g, "\u200C")
      .replace(/&lrm;/g, "\u200E")
      .replace(/&rlm;/g, "\u200F")
      .replace(/&shy;/g, "\u00AD")

      // Symbols
      .replace(/&copy;/g, "©")
      .replace(/&reg;/g, "®")
      .replace(/&trade;/g, "™")
      .replace(/&deg;/g, "°")
      .replace(/&sect;/g, "§")
      .replace(/&para;/g, "¶")
      .replace(/&middot;/g, "·")
      .replace(/&bull;/g, "•")
      .replace(/&dagger;/g, "†")
      .replace(/&Dagger;/g, "‡")

      // Handle specific problematic numeric entities first
      .replace(/&#39;/g, "'")
      .replace(/&#34;/g, '"')
      .replace(/&#38;/g, "&")
      .replace(/&#60;/g, "<")
      .replace(/&#62;/g, ">")
      .replace(/&#32;/g, " ")
      .replace(/&#160;/g, " ")
      .replace(/&#8217;/g, "'")
      .replace(/&#8216;/g, "'")
      .replace(/&#8220;/g, '"')
      .replace(/&#8221;/g, '"')
      .replace(/&#8211;/g, "–")
      .replace(/&#8212;/g, "—")
      .replace(/&#8230;/g, "...")

      // Handle general numeric entities (decimal)
      .replace(/&#(\d+);/g, (match, code) => {
        try {
          const charCode = parseInt(code, 10);
          if (charCode > 0 && charCode < 1114112) {
            return String.fromCharCode(charCode);
          }
          return "";
        } catch {
          return "";
        }
      })

      // Handle hexadecimal entities
      .replace(/&#x([a-fA-F0-9]+);/g, (match, code) => {
        try {
          const charCode = parseInt(code, 16);
          if (charCode > 0 && charCode < 1114112) {
            return String.fromCharCode(charCode);
          }
          return "";
        } catch {
          return "";
        }
      })

      // Keep ampersand LAST to avoid double-decoding
      .replace(/&amp;/g, "&")
  );
}

// Function to render LaTeX math to Unicode
function renderLatexMath(text: string): string {
  return text
    .replace(/\\\(\s*(\d+)\s+\\frac\{1\}\{2\}\s*\\\)/g, "$1½")
    .replace(/\\\(\s*(\d+)\s+\\frac\{1\}\{4\}\s*\\\)/g, "$1¼")
    .replace(/\\\(\s*(\d+)\s+\\frac\{3\}\{4\}\s*\\\)/g, "$1¾")
    .replace(/\\\(\s*(\d+)\\frac\{1\}\{2\}\s*\\\)/g, "$1½")
    .replace(/\\\(\s*(\d+)\\frac\{1\}\{4\}\s*\\\)/g, "$1¼")
    .replace(/\\\(\s*(\d+)\\frac\{3\}\{4\}\s*\\\)/g, "$1¾")
    .replace(/\\\(\s*\\frac\{1\}\{2\}\s*\\\)/g, "½")
    .replace(/\\\(\s*\\frac\{1\}\{4\}\s*\\\)/g, "¼")
    .replace(/\\\(\s*\\frac\{3\}\{4\}\s*\\\)/g, "¾")
    .replace(/\\\(\s*\\frac\{1\}\{3\}\s*\\\)/g, "⅓")
    .replace(/\\\(\s*\\frac\{2\}\{3\}\s*\\\)/g, "⅔")
    .replace(/\\\(\s*\\frac\{1\}\{5\}\s*\\\)/g, "⅕")
    .replace(/\\\(\s*\\frac\{2\}\{5\}\s*\\\)/g, "⅖")
    .replace(/\\\(\s*\\frac\{3\}\{5\}\s*\\\)/g, "⅗")
    .replace(/\\\(\s*\\frac\{4\}\{5\}\s*\\\)/g, "⅘")
    .replace(/\\\(\s*\\frac\{1\}\{6\}\s*\\\)/g, "⅙")
    .replace(/\\\(\s*\\frac\{5\}\{6\}\s*\\\)/g, "⅚")
    .replace(/\\\(\s*\\frac\{1\}\{8\}\s*\\\)/g, "⅛")
    .replace(/\\\(\s*\\frac\{3\}\{8\}\s*\\\)/g, "⅜")
    .replace(/\\\(\s*\\frac\{5\}\{8\}\s*\\\)/g, "⅝")
    .replace(/\\\(\s*\\frac\{7\}\{8\}\s*\\\)/g, "⅞")
    .replace(/\\\(\s*\\frac\{([^}]+)\}\{([^}]+)\}\s*\\\)/g, "($1/$2)")
    .replace(/\\\(/g, "")
    .replace(/\\\)/g, "")
    .replace(/\\\[/g, "")
    .replace(/\\\]/g, "");
}

// NEW: Function to process bilingual text inline (keep on same line with " / ")
function processBilingualTextInline(content: string): string {
  if (!content) return "";

  let decoded = decodeHtmlEntities(content);
  decoded = decoded.replace(/^<br\/?>\s*/gi, "").trim();

  // Check for existing <br/>[Hindi] or <br>[Hindi] format - convert to " / "
  const brHindiMatch = decoded.match(/^(.*?)<br\/?>\s*\[Hindi\]\s*(.*)$/s);
  if (brHindiMatch) {
    const englishPart = renderLatexMath(brHindiMatch[1].trim());
    const hindiPart = renderLatexMath(brHindiMatch[2].trim());
    return `${englishPart} / ${hindiPart}`;
  }

  // Check for standalone [Hindi] marker
  const standaloneHindiMatch = decoded.match(/^(.*?)\[Hindi\]\s*(.*)$/s);
  if (standaloneHindiMatch && decoded.includes("[Hindi]")) {
    const beforeHindi = standaloneHindiMatch[1].trim();
    let afterHindi = standaloneHindiMatch[2]
      .replace(/^\[Hindi\]\s*/, "")
      .trim();
    afterHindi = afterHindi.replace(/\[Hindi\]/g, "").trim();

    const englishPart = renderLatexMath(beforeHindi);
    const hindiPart = renderLatexMath(afterHindi);
    return `${englishPart} / ${hindiPart}`;
  }

  // Check for original " / " format - already in correct format
  if (decoded.includes(" / ")) {
    return renderLatexMath(decoded);
  }

  // Single language
  return renderLatexMath(decoded);
}

// NEW: Function to process solution text with proper headers
function processSolutionText(content: string): {
  english: string;
  hindi?: string;
} {
  if (!content) return { english: "" };

  let decoded = decodeHtmlEntities(content);
  decoded = decoded.replace(/^<br\/?>\s*/gi, "").trim();
  decoded = decoded.replace(/\[English Solution\]/gi, "").trim();

  // Check for existing <br/>[Hindi] format
  const brHindiMatch = decoded.match(/^(.*?)<br\/?>\s*\[Hindi\]\s*(.*)$/s);
  if (brHindiMatch) {
    const englishPart = renderLatexMath(brHindiMatch[1].trim());
    const hindiPart = renderLatexMath(brHindiMatch[2].trim());
    return { english: englishPart, hindi: hindiPart };
  }

  // Check for standalone [Hindi] marker
  const standaloneHindiMatch = decoded.match(/^(.*?)\[Hindi\]\s*(.*)$/s);
  if (standaloneHindiMatch && decoded.includes("[Hindi]")) {
    const beforeHindi = standaloneHindiMatch[1].trim();
    let afterHindi = standaloneHindiMatch[2]
      .replace(/^\[Hindi\]\s*/, "")
      .trim();
    afterHindi = afterHindi.replace(/\[Hindi\]/g, "").trim();

    const englishPart = renderLatexMath(beforeHindi);
    const hindiPart = renderLatexMath(afterHindi);
    return { english: englishPart, hindi: hindiPart };
  }

  //  Check for [Hindi Solution] marker
  const hindiSolutionMatch = decoded.match(/^(.*?)\[Hindi Solution\]\s*(.*)$/s);
  if (hindiSolutionMatch) {
    const englishPart = renderLatexMath(hindiSolutionMatch[1].trim());
    const hindiPart = renderLatexMath(hindiSolutionMatch[2].trim());
    return { english: englishPart, hindi: hindiPart };
  }

  const hindiRegex = /[\u0900-\u097F]+/g;
  // Split content into English and Hindi based on Devanagari letters-
  const hindiMatches = decoded.match(hindiRegex);
  if (hindiMatches) {
    const hindiPart = renderLatexMath(hindiMatches.join(" ").trim());
    const englishPart = renderLatexMath(decoded.replace(hindiRegex, "").trim());
    return { english: englishPart, hindi: hindiPart };
  }

  // Check for " / " separator
  const slashMatch = decoded.match(/^(.*?)\s+\/\s+(.*)$/s);
  if (slashMatch) {
    const englishPart = renderLatexMath(slashMatch[1].trim());
    const hindiPart = renderLatexMath(slashMatch[2].trim());
    return { english: englishPart, hindi: hindiPart };
  }

  // Single language
  return { english: renderLatexMath(decoded) };
}

// Enhanced HTML cleaning
function cleanHtmlContent(content: string): string {
  if (!content) return "";

  const decoded = decodeHtmlEntities(content);

  let cleaned = decoded.replace(/^<br\/?>\s*/gi, "").trim();

  let spaced = cleaned
    .replace(/<\/(b|strong|i|em|u|span)>/gi, " ")
    .replace(/<(b|strong|i|em|u|span)[^>]*>/gi, " ")
    .replace(/<\/?(br|p|div)[^>]*>/gi, " ")
    .replace(/<[^>]*>/g, "")
    .replace(/\s+/g, " ")
    .trim();

  return spaced;
}

// Function to create a Word document from questions
export function createWordDocument(
  questions: Question[],
  testName: string
): Document {
  const paragraphs: (Paragraph | Table)[] = [];

  // Add title
  paragraphs.push(
    new Paragraph({
      text: testName || "Question Bank Export",
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 },
    })
  );

  // Add questions
  questions.forEach((question, index) => {
    const questionNumber = index + 1;

    // Question text - bilingual on same line, no HTML
    const questionText = cleanHtmlContent(
      processBilingualTextInline(question.question)
    );
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `${questionNumber}. ${questionText}`,
            bold: true,
            size: 24,
          }),
        ],
        spacing: { before: 200, after: 100 },
      })
    );

    // Options (A, B, C, D, E) - bilingual on same line, no HTML
    const options = [
      { label: "A", text: question.option1 },
      { label: "B", text: question.option2 },
      { label: "C", text: question.option3 },
      { label: "D", text: question.option4 },
      { label: "E", text: question.option5 },
    ];

    options.forEach((option) => {
      if (option.text && option.text.trim()) {
        const optionText = cleanHtmlContent(
          processBilingualTextInline(option.text)
        );
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `${option.label}. ${optionText}`,
                size: 22,
              }),
            ],
            spacing: { before: 50, after: 50 },
            indent: { left: 400 },
          })
        );
      }
    });

    // Answer
    if (question.answer) {
      const answerLetter =
        ["A", "B", "C", "D", "E"][question.answer - 1] ||
        question.answer.toString();
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: "Answer: ",
              bold: false,
              size: 22,
            }),
            new TextRun({
              text: answerLetter,
              bold: true,
              size: 22,
              color: "008000",
            }),
          ],
          spacing: { before: 100, after: 100 },
        })
      );
    }

    // Solution section: Hindi and English as separate paragraphs, no headers, no HTML
    if (question.description && question.description.trim()) {
      const solutionContent = processSolutionText(question.description);

      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: "Solution.",
              bold: false,
              size: 22,
              color: "8B4513",
            }),
          ],
          spacing: { before: 150, after: 50 },
        })
      );

      // English solution (if exists)
      if (solutionContent.english) {
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: cleanHtmlContent(solutionContent.english),
                size: 22,
              }),
            ],
            spacing: { after: 100 },
          })
        );
      }

      // Hindi solution (if exists)
      if (solutionContent.hindi) {
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: cleanHtmlContent(solutionContent.hindi),
                size: 22,
              }),
            ],
            spacing: { after: 100 },
          })
        );
      }
    }

    // Add spacing between questions
    paragraphs.push(
      new Paragraph({
        text: "",
        spacing: { after: 400 },
      })
    );
  });

  return new Document({
    sections: [
      {
        properties: {},
        children: paragraphs,
      },
    ],
  });
}

