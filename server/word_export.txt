// // 2nd-------------------------------------------------------------------------------------------------------

// import {
//   Document,
//   Paragraph,
//   TextRun,
//   AlignmentType,
//   HeadingLevel,
//   Packer,
// } from "docx";
// import { Question } from "../shared/schema";
// import { parse } from "node-html-parser";
// import { replacements } from "./replacement.ts";

// // Unicodeit replacement data and functions

// const subsuperscripts: [string, string][] = [
//   ["_x", "ₓ"],
//   ["_v", "ᵥ"],
//   ["_u", "ᵤ"],
//   ["_t", "ₜ"],
//   ["_s", "ₛ"],
//   ["_r", "ᵣ"],
//   ["_p", "ₚ"],
//   ["_o", "ₒ"],
//   ["_n", "ₙ"],
//   ["_m", "ₘ"],
//   ["_l", "ₗ"],
//   ["_k", "ₖ"],
//   ["_j", "ⱼ"],
//   ["_i", "ᵢ"],
//   ["_h", "ₕ"],
//   ["_e", "ₑ"],
//   ["_a", "ₐ"],
//   ["^∫", "ᶴ"],
//   ["_>", "˲"],
//   ["_=", "₌"],
//   ["_<", "˱"],
//   ["_9", "₉"],
//   ["_8", "₈"],
//   ["_7", "₇"],
//   ["_6", "₆"],
//   ["_5", "₅"],
//   ["_4", "₄"],
//   ["_3", "₃"],
//   ["_2", "₂"],
//   ["_1", "₁"],
//   ["_0", "₀"],
//   ["_-", "₋"],
//   ["_−", "₋"],
//   ["_+", "₊"],
//   ["_)", "₎"],
//   ["_(", "₍"],
//   ["_ρ", "ᵨ"],
//   ["_χ", "ᵪ"],
//   ["_φ", "ᵩ"],
//   ["_β", "ᵦ"],
//   ["_γ", "ᵧ"],
//   ["^φ", "ᵠ"],
//   ["^χ", "ᵡ"],
//   ["^δ", "ᵟ"],
//   ["^γ", "ᵞ"],
//   ["^β", "ᵝ"],
//   ["^8", "⁸"],
//   ["^9", "⁹"],
//   ["^<", "˂"],
//   ["^=", "⁼"],
//   ["^>", "˃"],
//   ["^0", "⁰"],
//   ["^1", "¹"],
//   ["^2", "²"],
//   ["^3", "³"],
//   ["^4", "⁴"],
//   ["^5", "⁵"],
//   ["^6", "⁶"],
//   ["^7", "⁷"],
//   ["^(", "⁽"],
//   ["^)", "⁾"],
//   ["^*", "*"],
//   ["^+", "⁺"],
//   ["^-", "⁻"],
//   ["^−", "⁻"],
//   ["^.", "ᐧ"],
//   ["^P", "ᴾ"],
//   ["^R", "ᴿ"],
//   ["^T", "ᵀ"],
//   ["^U", "ᵁ"],
//   ["^V", "ᄑ"],
//   ["^W", "ᵂ"],
//   ["^H", "ᴴ"],
//   ["^I", "ᴵ"],
//   ["^J", "ᴶ"],
//   ["^K", "ᴷ"],
//   ["^L", "ᴸ"],
//   ["^M", "ᴹ"],
//   ["^N", "ᴺ"],
//   ["^O", "ᴼ"],
//   ["^A", "ᴬ"],
//   ["^B", "ᴮ"],
//   ["^D", "ᴰ"],
//   ["^E", "ᴱ"],
//   ["^G", "ᴳ"],
//   ["^x", "ˣ"],
//   ["^y", "ʸ"],
//   ["^z", "ᶻ"],
//   ["^p", "ᵖ"],
//   ["^r", "ʳ"],
//   ["^s", "ˢ"],
//   ["^t", "ᵗ"],
//   ["^u", "ᵘ"],
//   ["^v", "ᵛ"],
//   ["^w", "ʷ"],
//   ["^h", "ʰ"],
//   ["^i", "ⁱ"],
//   ["^j", "ʲ"],
//   ["^k", "ᵏ"],
//   ["^l", "ˡ"],
//   ["^m", "ᵐ"],
//   ["^n", "ⁿ"],
//   ["^o", "ᵒ"],
//   ["^a", "ᵃ"],
//   ["^b", "ᵇ"],
//   ["^c", "ᶜ"],
//   ["^d", "ᵈ"],
//   ["^e", "ᵉ"],
//   ["^f", "ᶠ"],
//   ["^g", "ᵍ"],
// ];

// const combiningmarks: [string, string][] = [
//   ["\\doubleunderline", "\u0333"],
//   ["\\strikethrough", "\u0335"],
//   ["\\underline", "\u0332"],
//   ["\\overline", "\u0305"],
//   ["\\tilde", "\u0303"],
//   ["\\grave", "\u0300"],
//   ["\\acute", "\u0301"],
//   ["\\slash", "\u0338"],
//   ["\\breve", "\u0306"],
//   ["\\ddot", "\u0308"],
//   ["\\dot", "\u0307"],
//   ["\\bar", "\u0305"],
//   ["\\vec", "\u20d7"],
//   ["\\hat", "\u0302"],
// ];

// // Unicodeit replace function adapted from the library
// function unicodeitReplace(text: string): string {
//   if (!text) return "";

//   // Ensure text is a string
//   if (typeof text !== "string") {
//     console.warn("unicodeitReplace received non-string:", typeof text, text);
//     text = String(text);
//   }

//   // Handle \not prefix (e.g., \not\subset -> \slash{\subset})
//   text = text.replace(/\\not(\\[A-z]+)/g, "\\slash{$1}");

//   if (!text) return "";

//   // Apply main replacements
//   for (const [latex, unicode] of replacements) {
//     if (latex instanceof RegExp) {
//       // If it's a regex, use .replace()
//       text = text.replace(latex, unicode);
//     } else {
//       // Otherwise, simple string replacement
//       text = text.split(latex).join(unicode);
//     }
//   }

//   // Handle superscripts in braces: ^{01234} -> ^0^1^2^3^4
//   let isup = -1;
//   while (
//     (isup = text.indexOf("^{", isup + 1)) > -1 &&
//     text.indexOf("}", isup + 1) > isup
//   ) {
//     const endBrace = text.indexOf("}", isup + 1);
//     const content = text.slice(isup + 2, endBrace);
//     if (content.length > 0) {
//       const expanded = content
//         .split("")
//         .map((c) => "^" + c)
//         .join("");
//       text = text.slice(0, isup) + expanded + text.slice(endBrace + 1);
//     }
//   }

//   // Handle subscripts in braces: _{01234} -> _0_1_2_3_4
//   let isub = -1;
//   while (
//     (isub = text.indexOf("_{", isub + 1)) > -1 &&
//     text.indexOf("}", isub + 1) > isub
//   ) {
//     const endBrace = text.indexOf("}", isub + 1);
//     const content = text.slice(isub + 2, endBrace);
//     if (content.length > 0) {
//       const expanded = content
//         .split("")
//         .map((c) => "_" + c)
//         .join("");
//       text = text.slice(0, isub) + expanded + text.slice(endBrace + 1);
//     }
//   }

//   // Apply subscript and superscript replacements
//   for (const [latex, unicode] of subsuperscripts) {
//     text = text.split(latex).join(unicode);
//   }

//   // Handle combining marks
//   for (const [latex, unicode] of combiningmarks) {
//     const pattern = new RegExp("\\\\" + latex.slice(1) + "\\{(.?)\\}", "g");
//     text = text.replace(pattern, (match, char) => {
//       return char ? char + unicode : unicode;
//     });
//   }

//   return text;
// }

// // function unicodeitReplace(text: any): string {
// //   if (!text) return "";
// //   if (typeof text !== "string") text = String(text);

// //   // Handle \not prefix
// //   text = text.replace(/\\not\\([A-Za-z]+)/g, (_, cmd) => {
// //     const slashChar = "\u0338";
// //     return "\\" + cmd + slashChar;
// //   });

// //   // Main replacements
// //   for (const [latex, unicode] of replacements) {
// //     const escapedLatex = latex.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
// //     text = text.replace(new RegExp(escapedLatex, "g"), unicode);
// //   }

// //   // Superscripts in braces
// //   text = text.replace(/\^\{([^}]+)\}/g, (_, content) =>
// //     content
// //       .split("")
// //       .map((c) => "^" + c)
// //       .join("")
// //   );

// //   // Subscripts in braces
// //   text = text.replace(/_\{([^}]+)\}/g, (_, content) =>
// //     content
// //       .split("")
// //       .map((c) => "_" + c)
// //       .join("")
// //   );

// //   // Apply subscript/superscript Unicode
// //   for (const [latex, unicode] of subsuperscripts) {
// //     const escapedLatex = latex.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
// //     text = text.replace(new RegExp(escapedLatex, "g"), unicode);
// //   }

// //   // Combining marks
// //   for (const [latex, unicode] of combiningmarks) {
// //     const cmdName = latex.slice(1);
// //     const pattern = new RegExp(`\\\\${cmdName}\\{(.?)\\}`, "g");
// //     text = text.replace(pattern, (_, char) =>
// //       char ? char + unicode : unicode
// //     );
// //   }

// //   return text;
// // }

// // Enhanced LaTeX to Unicode converter using unicodeit
// // function convertLatexToUnicode(text: string): string {
// //   if (!text) return "";

// //   // Handle text formatting commands
// //   text = text
// //     .replace(/\\rm\{([^}]+)\}/g, "$1")
// //     .replace(/\\rm\s+/g, "")
// //     .replace(/\\text\{([^}]+)\}/g, "$1")
// //     .replace(/\\mathrm\{([^}]+)\}/g, "$1")
// //     .replace(/\\textbf\{([^}]+)\}/g, "$1")
// //     .replace(/\\mathbf\{([^}]+)\}/g, "$1")
// //     .replace(/\\textit\{([^}]+)\}/g, "$1")
// //     .replace(/\\mathit\{([^}]+)\}/g, "$1");

// //   // Handle spacing commands
// //   text = text
// //     .replace(/\\;/g, " ")
// //     .replace(/\\,/g, " ")
// //     .replace(/\\:/g, " ")
// //     .replace(/\\!/g, "")
// //     .replace(/\\quad/g, "  ")
// //     .replace(/\\qquad/g, "    ")
// //     .replace(/\\\s/g, " ");

// //   // Handle special characters
// //   text = text
// //     .replace(/\\%/g, "%")
// //     .replace(/\\#/g, "#")
// //     .replace(/\\$/g, "$")
// //     .replace(/\\&/g, "&")
// //     .replace(/\\_/g, "_")
// //     .replace(/\\\{/g, "{")
// //     .replace(/\\\}/g, "}");

// //   // Handle parentheses
// //   text = text
// //     .replace(/\\left\(/g, "(")
// //     .replace(/\\right\)/g, ")")
// //     .replace(/\\left\[/g, "[")
// //     .replace(/\\right\]/g, "]")
// //     .replace(/\\left\{/g, "{")
// //     .replace(/\\right\}/g, "}")
// //     .replace(/\\left\|/g, "|")
// //     .replace(/\\right\|/g, "|")
// //     .replace(/\\left\./g, "")
// //     .replace(/\\right\./g, "");

// //   // Handle square root
// //   text = text
// //     .replace(/\\sqrt\{([^}]+)\}/g, "√($1)")
// //     .replace(/\\sqrt\[(\d+)\]\{([^}]+)\}/g, "$1√($2)");

// //   // Handle generic fractions (after specific ones)
// //   text = text
// //     .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, "($1/$2)")
// //     .replace(/\\dfrac\{([^}]+)\}\{([^}]+)\}/g, "($1/$2)")
// //     .replace(/\\tfrac\{([^}]+)\}\{([^}]+)\}/g, "($1/$2)");

// //   // Apply unicodeit replacements
// //   text = unicodeitReplace(text);

// //   // Handle trigonometric and other functions
// //   text = text
// //     .replace(/\\sin\b/g, "sin")
// //     .replace(/\\cos\b/g, "cos")
// //     .replace(/\\tan\b/g, "tan")
// //     .replace(/\\cot\b/g, "cot")
// //     .replace(/\\sec\b/g, "sec")
// //     .replace(/\\csc\b/g, "csc")
// //     .replace(/\\log\b/g, "log")
// //     .replace(/\\ln\b/g, "ln")
// //     .replace(/\\exp\b/g, "exp")
// //     .replace(/\\lim\b/g, "lim")
// //     .replace(/\\max\b/g, "max")
// //     .replace(/\\min\b/g, "min");

// //   // Clean up extra spaces
// //   text = text.replace(/\s+/g, " ").trim();

// //   return text;
// // }

// // Add this before convertLatexToUnicode

// function isBalancedBraces(text: string): boolean {
//   let count = 0;
//   for (const char of text) {
//     if (char === "{") count++;
//     if (char === "}") count--;
//     if (count < 0) return false;
//   }
//   return count === 0;
// }

// function extractBracedContent(
//   text: string,
//   start: number
// ): { content: string; end: number } {
//   if (text[start] !== "{") return { content: "", end: start };

//   let braceCount = 1;
//   let end = start + 1;

//   while (braceCount > 0 && end < text.length) {
//     if (text[end] === "{") braceCount++;
//     if (text[end] === "}") braceCount--;
//     end++;
//   }

//   return {
//     content: text.slice(start + 1, end - 1),
//     end: end,
//   };
// }

// // function convertLatexToUnicode(text: string): string {
// //   if (!text) return "";

// //   // Text formatting
// //   text = text
// //     .replace(/\\rm\{([^}]+)\}/g, "$1")
// //     .replace(/\\text\{([^}]+)\}/g, "$1")
// //     .replace(/\\mathrm\{([^}]+)\}/g, "$1")
// //     .replace(/\\textbf\{([^}]+)\}/g, "$1")
// //     .replace(/\\mathbf\{([^}]+)\}/g, "$1")
// //     .replace(/\\textit\{([^}]+)\}/g, "$1")
// //     .replace(/\\mathit\{([^}]+)\}/g, "$1");

// //   // Spacing
// //   text = text
// //     .replace(/\\[;,!:\s]/g, " ")
// //     .replace(/\\quad/g, "  ")
// //     .replace(/\\qquad/g, "    ");

// //   // Special characters
// //   text = text
// //     .replace(/\\%/g, "%")
// //     .replace(/\\#/g, "#")
// //     .replace(/\\$/g, "$")
// //     .replace(/\\&/g, "&")
// //     .replace(/\\_/g, "_")
// //     .replace(/\\\{/g, "{")
// //     .replace(/\\\}/g, "}");

// //   // Parentheses
// //   text = text
// //     .replace(/\\left\(/g, "(")
// //     .replace(/\\right\)/g, ")")
// //     .replace(/\\left\[/g, "[")
// //     .replace(/\\right\]/g, "]")
// //     .replace(/\\left\{/g, "{")
// //     .replace(/\\right\}/g, "}")
// //     .replace(/\\left\|/g, "|")
// //     .replace(/\\right\|/g, "|")
// //     .replace(/\\left\./g, "")
// //     .replace(/\\right\./g, "");

// //   // Fractions (specific first)
// //   text = text.replace(/\\d?frac\{([^}]+)\}\{([^}]+)\}/g, "($1/$2)");

// //   // Square roots
// //   text = text
// //     .replace(/\\sqrt\[(\d+)\]\{([^}]+)\}/g, "$1√($2)")
// //     .replace(/\\sqrt\{([^}]+)\}/g, "√($1)");

// //   // Trig & functions
// //   text = text.replace(
// //     /\\(sin|cos|tan|cot|sec|csc|log|ln|exp|lim|max|min)\b/g,
// //     "$1"
// //   );

// //   // Apply unicodeit replacements **after formatting but before final cleanup**
// //   text = unicodeitReplace(text);

// //   // Cleanup extra spaces
// //   text = text.replace(/\s+/g, " ").trim();

// //   return text;
// // }

// // Decode HTML entities

// // function convertLatexToUnicode(text: string): string {
// //   if (!text) return "";

// //   // Pre-process special cases
// //   text = text
// //     // Handle spaces
// //     .replace(/\\,/g, " ")
// //     .replace(/\\;/g, "  ")
// //     .replace(/\\:/g, " ")
// //     .replace(/\\!/g, "")
// //     .replace(/\\quad/g, "    ")
// //     .replace(/\\qquad/g, "        ")

// //     // Handle fractions
// //     .replace(/\\frac\{([^{}]+)\}\{([^{}]+)\}/g, "$1⁄$2")

// //     // Handle powers and subscripts
// //     .replace(/\^(\{[^{}]+\}|\d)/g, (_, exp) => {
// //       exp = exp.replace(/[{}]/g, "");
// //       return exp
// //         .split("")
// //         .map((c) => {
// //           const superscript =
// //             {
// //               "0": "⁰",
// //               "1": "¹",
// //               "2": "²",
// //               "3": "³",
// //               "4": "⁴",
// //               "5": "⁵",
// //               "6": "⁶",
// //               "7": "⁷",
// //               "8": "⁸",
// //               "9": "⁹",
// //               "+": "⁺",
// //               "-": "⁻",
// //               "=": "⁼",
// //               "(": "⁽",
// //               ")": "⁾",
// //               n: "ⁿ",
// //             }[c] || c;
// //           return superscript;
// //         })
// //         .join("");
// //     })

// //     // Handle common math operators
// //     .replace(/\\sum\b/g, "∑")
// //     .replace(/\\prod\b/g, "∏")
// //     .replace(/\\int\b/g, "∫")
// //     .replace(/\\infty\b/g, "∞")
// //     .replace(/\\partial\b/g, "∂");

// //   // Apply unicodeit replacements

// //   // In convertLatexToUnicode, before calling unicodeitReplace:
// //   text = replaceFractions(text);
// //   text = unicodeitReplace(text);

// //   // Post-process cleanup
// //   text = text
// //     .replace(/\\\s/g, " ")
// //     .replace(/\\textbf\{([^}]+)\}/g, "$1")
// //     .replace(/\\text\{([^}]+)\}/g, "$1")
// //     .replace(/\\mathrm\{([^}]+)\}/g, "$1")
// //     .replace(/\s+/g, " ")
// //     .trim();

// //   return text;
// // }

// //

// // function convertLatexToUnicode(text: string): string {
// //   if (!text) return "";

// //   // Pre-process special cases
// //   text = text
// //     // Handle spaces
// //     .replace(/\\,/g, " ")
// //     .replace(/\\;/g, "  ")
// //     .replace(/\\:/g, " ")
// //     .replace(/\\!/g, "")
// //     .replace(/\\quad/g, "    ")
// //     .replace(/\\qquad/g, "        ")

// //     // Handle fractions
// //     .replace(/\\frac\{([^{}]+)\}\{([^{}]+)\}/g, "$1⁄$2")

// //     // Handle powers (improved to handle complex expressions)
// //     .replace(/\^(\{[^{}]*\}|[^{}\s])/g, (_, exp) => {
// //       // Remove braces if present
// //       exp = exp.replace(/[{}]/g, "");
// //       // Handle each character in the exponent
// //       return exp
// //         .split("")
// //         .map((c) => {
// //           const superscript =
// //             {
// //               "0": "⁰",
// //               "1": "¹",
// //               "2": "²",
// //               "3": "³",
// //               "4": "⁴",
// //               "5": "⁵",
// //               "6": "⁶",
// //               "7": "⁷",
// //               "8": "⁸",
// //               "9": "⁹",
// //               "+": "⁺",
// //               "-": "⁻",
// //               "=": "⁼",
// //               "(": "⁽",
// //               ")": "⁾",
// //               n: "ⁿ",
// //               i: "ⁱ",
// //               x: "ˣ",
// //               y: "ʸ",
// //               z: "ᶻ",
// //               a: "ᵃ",
// //               b: "ᵇ",
// //               c: "ᶜ",
// //               d: "ᵈ",
// //               e: "ᵉ",
// //               f: "ᶠ",
// //               g: "ᵍ",
// //               h: "ʰ",
// //               j: "ʲ",
// //               k: "ᵏ",
// //               l: "ˡ",
// //               m: "ᵐ",
// //               o: "ᵒ",
// //               p: "ᵖ",
// //               r: "ʳ",
// //               s: "ˢ",
// //               t: "ᵗ",
// //               u: "ᵘ",
// //               v: "ᵛ",
// //               w: "ʷ",
// //               // Add more letters or symbols as needed
// //             }[c] || c; // Fallback to original character if no mapping
// //           return superscript;
// //         })
// //         .join("");
// //     })

// //     // Handle subscripts
// //     .replace(/_(\{[^{}]*\}|[^{}\s])/g, (_, sub) => {
// //       sub = sub.replace(/[{}]/g, "");
// //       return sub
// //         .split("")
// //         .map((c) => {
// //           const subscript =
// //             {
// //               "0": "₀",
// //               "1": "₁",
// //               "2": "₂",
// //               "3": "₃",
// //               "4": "₄",
// //               "5": "₅",
// //               "6": "₆",
// //               "7": "₇",
// //               "8": "₈",
// //               "9": "₉",
// //               "+": "₊",
// //               "-": "₋",
// //               "=": "₌",
// //               "(": "₍",
// //               ")": "₎",
// //               x: "ₓ",
// //               v: "ᵥ",
// //               u: "ᵤ",
// //               t: "ₜ",
// //               s: "ₛ",
// //               r: "ᵣ",
// //               p: "ₚ",
// //               o: "ₒ",
// //               n: "ₙ",
// //               m: "ₘ",
// //               l: "ₗ",
// //               k: "ₖ",
// //               j: "ⱼ",
// //               i: "ᵢ",
// //               h: "ₕ",
// //               e: "ₑ",
// //               a: "ₐ",
// //               ρ: "ᵨ",
// //               χ: "ᵪ",
// //               φ: "ᵩ",
// //               β: "ᵦ",
// //               γ: "ᵧ",
// //             }[c] || c;
// //           return subscript;
// //         })
// //         .join("");
// //     })

// //     // Handle common math operators
// //     .replace(/\\sum\b/g, "∑")
// //     .replace(/\\prod\b/g, "∏")
// //     .replace(/\\int\b/g, "∫")
// //     .replace(/\\infty\b/g, "∞")
// //     .replace(/\\partial\b/g, "∂");

// //   // Apply unicodeit replacements
// //   text = unicodeitReplace(text);

// //   // Post-process cleanup
// //   text = text
// //     .replace(/\\\s/g, " ")
// //     .replace(/\\textbf\{([^}]+)\}/g, "$1")
// //     .replace(/\\text\{([^}]+)\}/g, "$1")
// //     .replace(/\\mathrm\{([^}]+)\}/g, "$1")
// //     .replace(/\s+/g, " ")
// //     .trim();

// //   return text;
// // }

// function convertLatexToUnicode(text: string): string {
//   if (!text) return "";

//   // Pre-process special cases
//   text = text
//     // Handle spaces
//     .replace(/\\,/g, " ")
//     .replace(/\\;/g, "  ")
//     .replace(/\\:/g, " ")
//     .replace(/\\!/g, "")
//     .replace(/\\quad/g, "    ")
//     .replace(/\\qquad/g, "        ");

//   // Handle recursive fractions
//   text = replaceFractions(text);

//   // Handle powers/superscripts recursively
//   function replaceSuperscripts(text: string): string {
//     return text.replace(/\^(\{[^{}]*\}|[^{}\s])/g, (_, exp) => {
//       exp = exp.replace(/[{}]/g, "");
//       // Recurse for nesting
//       exp = replaceSuperscripts(exp);
//       return exp
//         .split("")
//         .map((c) => {
//           const superscript =
//             {
//               "0": "⁰",
//               "1": "¹",
//               "2": "²",
//               "3": "³",
//               "4": "⁴",
//               "5": "⁵",
//               "6": "⁶",
//               "7": "⁷",
//               "8": "⁸",
//               "9": "⁹",
//               "+": "⁺",
//               "-": "⁻",
//               "=": "⁼",
//               "(": "⁽",
//               ")": "⁾",
//               n: "ⁿ",
//               i: "ⁱ",
//               x: "ˣ",
//               y: "ʸ",
//               z: "ᶻ",
//               a: "ᵃ",
//               b: "ᵇ",
//               c: "ᶜ",
//               d: "ᵈ",
//               e: "ᵉ",
//               f: "ᶠ",
//               g: "ᵍ",
//               h: "ʰ",
//               j: "ʲ",
//               k: "ᵏ",
//               l: "ˡ",
//               m: "ᵐ",
//               o: "ᵒ",
//               p: "ᵖ",
//               r: "ʳ",
//               s: "ˢ",
//               t: "ᵗ",
//               u: "ᵘ",
//               v: "ᵛ",
//               w: "ʷ",
//             }[c] || c; // Fallback to original
//         })
//         .join("");
//     });
//   }
//   text = replaceSuperscripts(text);

//   // Handle subscripts recursively
//   function replaceSubscripts(text: string): string {
//     return text.replace(/_(\{[^{}]*\}|[^{}\s])/g, (_, sub) => {
//       sub = sub.replace(/[{}]/g, "");
//       // Recurse for nesting
//       sub = replaceSubscripts(sub);
//       return sub
//         .split("")
//         .map((c) => {
//           const subscript =
//             {
//               "0": "₀",
//               "1": "₁",
//               "2": "₂",
//               "3": "₃",
//               "4": "₄",
//               "5": "₅",
//               "6": "₆",
//               "7": "₇",
//               "8": "₈",
//               "9": "₉",
//               "+": "₊",
//               "-": "₋",
//               "=": "₌",
//               "(": "₍",
//               ")": "₎",
//               x: "ₓ",
//               v: "ᵥ",
//               u: "ᵤ",
//               t: "ₜ",
//               s: "ₛ",
//               r: "ᵣ",
//               p: "ₚ",
//               o: "ₒ",
//               n: "ₙ",
//               m: "ₘ",
//               l: "ₗ",
//               k: "ₖ",
//               j: "ⱼ",
//               i: "ᵢ",
//               h: "ₕ",
//               e: "ₑ",
//               a: "ₐ",
//               ρ: "ᵨ",
//               χ: "ᵪ",
//               φ: "ᵩ",
//               β: "ᵦ",
//               γ: "ᵧ",
//             }[c] || c; // Fallback to original
//         })
//         .join("");
//     });
//   }
//   text = replaceSubscripts(text);

//   // Handle common math operators
//   text = text
//     .replace(/\\sum\b/g, "∑")
//     .replace(/\\prod\b/g, "∏")
//     .replace(/\\int\b/g, "∫")
//     .replace(/\\infty\b/g, "∞")
//     .replace(/\\partial\b/g, "∂");

//   // Apply unicodeit replacements
//   text = unicodeitReplace(text);

//   // Post-process cleanup
//   text = text
//     .replace(/\\\s/g, " ")
//     .replace(/\\textbf\{([^}]+)\}/g, "$1")
//     .replace(/\\text\{([^}]+)\}/g, "$1")
//     .replace(/\\mathrm\{([^}]+)\}/g, "$1")
//     .replace(/\s+/g, " ")
//     .trim();

//   // Normalize minus signs and superscript exponents in dimensional formulas like [ML2T-2]
//   text = text.replace(/−/g, "-"); // Normalize en dash/minus to hyphen
//   text = text.replace(/\[([^\]]+)\]/g, (match, content) => {
//     // Remove spaces for consistency
//     content = content.replace(/\s/g, "");
//     // Superscript exponents (e.g., L2 → L², T-2 → T⁻², K+1 → K⁺¹)
//     content = content.replace(
//       /([A-Z])([-+])?(\d+)/g,
//       (_, letter, sign, num) => {
//         let superSign = "";
//         if (sign === "-") {
//           superSign = "⁻";
//         } else if (sign === "+") {
//           superSign = "⁺";
//         }
//         // Superscript digits (handles multi-digit like -10)
//         const superNum = num
//           .split("")
//           .map(
//             (d) =>
//               ({
//                 "0": "⁰",
//                 "1": "¹",
//                 "2": "²",
//                 "3": "³",
//                 "4": "⁴",
//                 "5": "⁵",
//                 "6": "⁶",
//                 "7": "⁷",
//                 "8": "⁸",
//                 "9": "⁹",
//               }[d])
//           )
//           .join("");
//         return letter + superSign + superNum;
//       }
//     );
//     return "[" + content + "]";
//   });

//   return text;
// }

// function decodeHtmlEntities(content: string): string {
//   if (!content) return "";

//   return content
//     .replace(/&amp;quot;/g, '"')
//     .replace(/&amp;amp;/g, "&")
//     .replace(/&amp;lt;/g, "<")
//     .replace(/&amp;gt;/g, ">")
//     .replace(/&amp;nbsp;/g, " ")
//     .replace(/&lt;/g, "<")
//     .replace(/&gt;/g, ">")
//     .replace(/&quot;/g, '"')
//     .replace(/&#39;/g, "'")
//     .replace(/&apos;/g, "'")
//     .replace(/&nbsp;/g, " ")
//     .replace(/&aacute;/g, "á")
//     .replace(/&Aacute;/g, "Á")
//     .replace(/&eacute;/g, "é")
//     .replace(/&Eacute;/g, "É")
//     .replace(/&iacute;/g, "í")
//     .replace(/&Iacute;/g, "Í")
//     .replace(/&oacute;/g, "ó")
//     .replace(/&Oacute;/g, "Ó")
//     .replace(/&uacute;/g, "ú")
//     .replace(/&Uacute;/g, "Ú")
//     .replace(/&ntilde;/g, "ñ")
//     .replace(/&Ntilde;/g, "Ñ")
//     .replace(/&#(\d+);/g, (match, code) => {
//       try {
//         const charCode = parseInt(code, 10);
//         if (charCode > 0 && charCode < 1114112) {
//           return String.fromCharCode(charCode);
//         }
//         return "";
//       } catch {
//         return "";
//       }
//     })
//     .replace(/&#x([a-fA-F0-9]+);/g, (match, code) => {
//       try {
//         const charCode = parseInt(code, 16);
//         if (charCode > 0 && charCode < 1114112) {
//           return String.fromCharCode(charCode);
//         }
//         return "";
//       } catch {
//         return "";
//       }
//     })
//     .replace(/&amp;/g, "&");
// }

// // // Render LaTeX math to Unicode

// // function renderLatexMath(text: string): string {
// //   if (!text) return "";

// //   try {
// //     // Handle display math \[ ... \]
// //     text = text.replace(/\\\[([\s\S]*?)\\\]/g, (match, latex) => {
// //       return convertLatexToUnicode(latex.trim());
// //     });

// //     // Handle inline math \( ... \)
// //     text = text.replace(/\\\(([\s\S]*?)\\\)/g, (match, latex) => {
// //       return convertLatexToUnicode(latex.trim());
// //     });

// //     // Handle display $$ ... $$
// //     text = text.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
// //       return convertLatexToUnicode(latex.trim());
// //     });

// //     // Handle inline $ ... $
// //     text = text.replace(/\$([^\$\n]+?)\$/g, (match, latex) => {
// //       return convertLatexToUnicode(latex.trim());
// //     });

// //     return text;
// //   } catch (error) {
// //     console.error("Error rendering LaTeX:", error);
// //     return text;
// //   }
// // }

// // function renderLatexMath(text: string): string {
// //   if (!text) return "";

// //   try {
// //     // Fix double-escaped backslashes that might come from HTML
// //     text = text.replace(/\\\\\\\\/g, "\\\\"); // \\\\ -> \\
// //     text = text.replace(/\\\\\(/g, "\\(");
// //     text = text.replace(/\\\\\)/g, "\\)");
// //     text = text.replace(/\\\\\[/g, "\\[");
// //     text = text.replace(/\\\\\]/g, "\\]");

// //     // Handle display math \[ ... \]
// //     text = text.replace(/\\\[([\s\S]*?)\\\]/g, (match, latex) => {
// //       const converted = convertLatexToUnicode(latex.trim());
// //       console.log("Display math:", latex.trim(), "->", converted);
// //       return converted;
// //     });

// //     // Handle inline math \( ... \)
// //     text = text.replace(/\\\(([\s\S]*?)\\\)/g, (match, latex) => {
// //       const converted = convertLatexToUnicode(latex.trim());
// //       console.log("Inline math:", latex.trim(), "->", converted);
// //       return converted;
// //     });

// //     // Handle display $ ... $ (must come before single $)
// //     text = text.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
// //       const converted = convertLatexToUnicode(latex.trim());
// //       console.log("Display $:", latex.trim(), "->", converted);
// //       return converted;
// //     });

// //     // Handle inline $ ... $ (improved regex to avoid matching $)
// //     // Use negative lookbehind and lookahead to avoid matching $
// //     text = text.replace(
// //       /(?<!\$)\$(?!\$)([^\$\n]+?)\$(?!\$)/g,
// //       (match, latex) => {
// //         const converted = convertLatexToUnicode(latex.trim());
// //         console.log("Inline $:", latex.trim(), "->", converted);
// //         return converted;
// //       }
// //     );

// //     // FALLBACK: If text still contains LaTeX commands (backslash followed by letters)
// //     // and no math delimiters were found, try direct conversion
// //     if (/\\[a-zA-Z]+/.test(text)) {
// //       console.log("Fallback: Converting raw LaTeX");
// //       text = convertLatexToUnicode(text);
// //     }

// //     return text;
// //   } catch (error) {
// //     console.error("Error rendering LaTeX:", error);
// //     return text;
// //   }
// // }

// // Check if content contains images

// // function renderLatexMath(text: string): string {
// //   if (!text) return "";

// //   try {
// //     // Fix double-escaped backslashes from HTML
// //     text = text
// //       .replace(/\\\\\\\\/g, "\\\\")
// //       .replace(/\\\\\(/g, "\\(")
// //       .replace(/\\\\\)/g, "\\)")
// //       .replace(/\\\\\[/g, "\\[")
// //       .replace(/\\\\\]/g, "\\]");

// //     // Display math \[...\]
// //     text = text.replace(/\\\[([\s\S]*?)\\\]/g, (_, latex) =>
// //       convertLatexToUnicode(latex.trim())
// //     );

// //     // Inline math \(...\)
// //     text = text.replace(/\\\(([\s\S]*?)\\\)/g, (_, latex) =>
// //       convertLatexToUnicode(latex.trim())
// //     );

// //     // Display $$...$$
// //     text = text.replace(/\$\$([\s\S]*?)\$\$/g, (_, latex) =>
// //       convertLatexToUnicode(latex.trim())
// //     );

// //     // Inline $...$
// //     text = text.replace(/(?<!\$)\$(?!\$)([^\$\n]+?)\$(?!\$)/g, (_, latex) =>
// //       convertLatexToUnicode(latex.trim())
// //     );

// //     // Fallback: convert any remaining LaTeX
// //     if (/\\[a-zA-Z]+/.test(text)) {
// //       text = convertLatexToUnicode(text);
// //     }

// //     return text;
// //   } catch (error) {
// //     console.error("Error rendering LaTeX:", error);
// //     return text;
// //   }
// // }

// // function renderLatexMath(text: string): string {
// //   if (!text) return "";

// //   try {
// //     // First unescape any escaped LaTeX delimiters
// //     text = text
// //       .replace(/\\\$/g, "___DOLLAR___") // Save escaped dollars
// //       .replace(/\\\[/g, "___LBRACK___") // Save escaped brackets
// //       .replace(/\\\]/g, "___RBRACK___");

// //     // Handle display math environments
// //     const delimiters = [
// //       { start: "\\[", end: "\\]" },
// //       { start: "\\(", end: "\\)" },
// //       { start: "$$", end: "$$" },
// //       { start: "$", end: "$" },
// //     ];

// //     for (const { start, end } of delimiters) {
// //       text = text
// //         .split(start)
// //         .map((part, i) => {
// //           if (i === 0) return part;
// //           const [math, ...rest] = part.split(end);
// //           return convertLatexToUnicode(math.trim()) + rest.join(end);
// //         })
// //         .join("");
// //     }

// //     // Restore escaped delimiters
// //     text = text
// //       .replace(/___DOLLAR___/g, "$")
// //       .replace(/___LBRACK___/g, "[")
// //       .replace(/___RBRACK___/g, "]");

// //     return text;
// //   } catch (error) {
// //     console.error("Error rendering LaTeX:", error);
// //     return text;
// //   }
// // }

// function renderLatexMath(text: string): string {
//   if (!text) return "";

//   try {
//     // First unescape any escaped LaTeX delimiters
//     text = text
//       .replace(/\\\$/g, "___DOLLAR___") // Save escaped dollars
//       .replace(/\\\[/g, "___LBRACK___") // Save escaped brackets
//       .replace(/\\\]/g, "___RBRACK___");

//     // Handle display math environments
//     const delimiters = [
//       { start: "\\[", end: "\\]" },
//       { start: "\\(", end: "\\)" },
//       { start: "$$", end: "$$" },
//       { start: "$", end: "$" },
//     ];

//     for (const { start, end } of delimiters) {
//       text = text
//         .split(start)
//         .map((part, i) => {
//           if (i === 0) return part;
//           const [math, ...rest] = part.split(end);
//           return convertLatexToUnicode(math.trim()) + rest.join(end);
//         })
//         .join("");
//     }

//     // Restore escaped delimiters
//     text = text
//       .replace(/___DOLLAR___/g, "$")
//       .replace(/___LBRACK___/g, "[")
//       .replace(/___RBRACK___/g, "]");

//     // *** NEW: Fallback for raw LaTeX without delimiters ***
//     // Detect if there are still LaTeX commands like \frac, \alpha, etc.
//     if (/\\[a-zA-Z]+/.test(text)) {
//       text = convertLatexToUnicode(text);
//     }

//     return text;
//   } catch (error) {
//     console.error("Error rendering LaTeX:", error);
//     return text;
//   }
// }

// function replaceFractions(text: string): string {
//   const fractionRegex = /\\frac\{([\s\S]*?)\}\{([\s\S]*?)\}/g;
//   return text.replace(fractionRegex, (match, num, den) => {
//     // Recurse on numerator and denominator
//     return `${replaceFractions(num)}∕${replaceFractions(den)}`;
//   });
// }

// function containsImage(content: string): boolean {
//   if (!content) return false;
//   return (
//     /<img[^>]*>/gi.test(content) ||
//     /data:image\/[^;]+;base64,/gi.test(content) ||
//     /\.(jpg|jpeg|png|gif|bmp|svg|webp)/gi.test(content)
//   );
// }

// // Extract image URLs
// function extractImageUrls(content: string): string[] {
//   if (!content) return [];
//   const urls: string[] = [];
//   const root = parse(content);
//   const imgTags = root.querySelectorAll("img");
//   imgTags.forEach((img) => {
//     const src = img.getAttribute("src");
//     if (src) urls.push(src);
//   });
//   return urls;
// }

// // Process bilingual content
// function processBilingualText(content: string): {
//   english: string;
//   hindi: string;
// } {
//   if (!content) return { english: "", hindi: "" };

//   const decoded = decodeHtmlEntities(content);
//   const root = parse(decoded);

//   // Remove all img tags
//   root.querySelectorAll("img").forEach((img) => img.remove());

//   let text = root.textContent || "";
//   text = text.replace(/\s+/g, " ").trim();
//   text = text.replace(/\[English Solution\]/gi, "").trim();
//   text = renderLatexMath(text);

//   // Check for <br/>[Hindi] or <br>[Hindi] format
//   const brHindiMatch = text.match(/^(.*?)<br\/?>\s*\[Hindi\]\s*(.*)$/s);
//   if (brHindiMatch) {
//     return {
//       english: brHindiMatch[1].trim(),
//       hindi: brHindiMatch[2].trim(),
//     };
//   }

//   // Check for standalone [Hindi] marker
//   const standaloneHindiMatch = text.match(/^(.*?)\[Hindi\]\s*(.*)$/s);
//   if (standaloneHindiMatch && text.includes("[Hindi]")) {
//     const beforeHindi = standaloneHindiMatch[1].trim();
//     let afterHindi = standaloneHindiMatch[2]
//       .replace(/^\[Hindi\]\s*/, "")
//       .trim();
//     afterHindi = afterHindi.replace(/\[Hindi\]/g, "").trim();
//     return {
//       english: beforeHindi,
//       hindi: afterHindi,
//     };
//   }

//   // Check for " / " separator
//   const slashMatch = text.match(/^(.*?)\s+\/\s+(.*)$/s);
//   if (slashMatch) {
//     return {
//       english: slashMatch[1].trim(),
//       hindi: slashMatch[2].trim(),
//     };
//   }

//   // Check for [Hindi Solution] marker
//   const hindiSolutionMatch1 = text.match(/^(.*?)\[Hindi Solution\]\s*(.*)$/is);
//   if (hindiSolutionMatch1) {
//     return {
//       english: hindiSolutionMatch1[1].trim(),
//       hindi: hindiSolutionMatch1[2].trim(),
//     };
//   }

//   const hindiSolutionMatch = text.match(
//     /^(.*?)---\s*\[Hindi Solution\]\s*(.*)$/is
//   );
//   if (hindiSolutionMatch) {
//     return {
//       english: hindiSolutionMatch[1].trim(),
//       hindi: hindiSolutionMatch[2].trim(),
//     };
//   }

//   // Detect Devanagari script
//   const hindiRegex = /[\u0900-\u097F]+/g;
//   const hindiMatches = text.match(hindiRegex);
//   if (hindiMatches) {
//     const hindiPart = hindiMatches.join(" ").trim();
//     const englishPart = text.replace(hindiRegex, "").trim();
//     return {
//       english: englishPart,
//       hindi: hindiPart,
//     };
//   }

//   return { english: text, hindi: "" };
// }

// // Create Word document
// export function createWordDocument(
//   questions: Question[],
//   testName: string
// ): Document {
//   console.dir(questions);

//   const paragraphs: Paragraph[] = [];

//   questions.forEach((question, index) => {
//     const qNum = index + 1;

//     // Question number
//     paragraphs.push(
//       new Paragraph({
//         children: [
//           new TextRun({
//             text: `${qNum}.`,
//             bold: true,
//             size: 26,
//           }),
//         ],
//         spacing: { before: 200, after: 100 },
//       })
//     );

//     // Question text
//     const questionProcessed = processBilingualText(question.question);

//     if (questionProcessed.english) {
//       paragraphs.push(
//         new Paragraph({
//           children: [
//             new TextRun({
//               text: questionProcessed.english,
//               size: 24,
//             }),
//           ],
//           spacing: { after: 100 },
//         })
//       );
//     }

//     if (questionProcessed.hindi) {
//       paragraphs.push(
//         new Paragraph({
//           children: [
//             new TextRun({
//               text: questionProcessed.hindi,
//               size: 24,
//             }),
//           ],
//           spacing: { after: 150 },
//         })
//       );
//     }

//     // Question images
//     if (containsImage(question.question)) {
//       const questionImages = extractImageUrls(question.question);
//       questionImages.forEach((url, idx) => {
//         paragraphs.push(
//           new Paragraph({
//             children: [
//               new TextRun({
//                 text: `[Question Image ${idx + 1}: ${url}]`,
//                 size: 20,
//                 color: "0000FF",
//                 italics: true,
//               }),
//             ],
//             spacing: { before: 50, after: 50 },
//           })
//         );
//       });
//     }

//     // Options
//     const options = [
//       { label: "A", text: question.option1 },
//       { label: "B", text: question.option2 },
//       { label: "C", text: question.option3 },
//       { label: "D", text: question.option4 },
//       { label: "E", text: question.option5 },
//     ];

//     options.forEach((opt) => {
//       if (opt.text && opt.text.trim()) {
//         const optionProcessed = processBilingualText(opt.text);
//         let optionText = optionProcessed.english;
//         if (optionProcessed.hindi) {
//           optionText = `${optionProcessed.english} / ${optionProcessed.hindi}`;
//         }

//         paragraphs.push(
//           new Paragraph({
//             children: [
//               new TextRun({
//                 text: `${opt.label}. `,
//                 bold: true,
//                 size: 24,
//               }),
//               new TextRun({
//                 text: optionText,
//                 size: 24,
//               }),
//             ],
//             spacing: { before: 80, after: 80 },
//           })
//         );

//         if (containsImage(opt.text)) {
//           const optImages = extractImageUrls(opt.text);
//           optImages.forEach((url, idx) => {
//             paragraphs.push(
//               new Paragraph({
//                 children: [
//                   new TextRun({
//                     text: `   [Option ${opt.label} Image ${idx + 1}: ${url}]`,
//                     size: 18,
//                     color: "0000FF",
//                     italics: true,
//                   }),
//                 ],
//                 spacing: { before: 30, after: 30 },
//               })
//             );
//           });
//         }
//       }
//     });

//     // Answer
//     if (question.answer) {
//       const answerLetter =
//         ["A", "B", "C", "D", "E"][question.answer - 1] ||
//         question.answer.toString();

//       paragraphs.push(
//         new Paragraph({
//           text: "",
//           spacing: { before: 150 },
//         })
//       );

//       paragraphs.push(
//         new Paragraph({
//           children: [
//             new TextRun({
//               text: "Answer: ",
//               bold: true,
//               size: 24,
//             }),
//             new TextRun({
//               text: answerLetter,
//               bold: true,
//               size: 26,
//               color: "008000",
//             }),
//           ],
//           spacing: { after: 150 },
//         })
//       );
//     }

//     // Solution
//     if (question.description && question.description.trim()) {
//       const explanationProcessed = processBilingualText(question.description);

//       paragraphs.push(
//         new Paragraph({
//           children: [
//             new TextRun({
//               text: "Solution:",
//               bold: true,
//               size: 24,
//             }),
//           ],
//           spacing: { before: 100, after: 100 },
//         })
//       );

//       if (explanationProcessed.english) {
//         paragraphs.push(
//           new Paragraph({
//             children: [
//               new TextRun({
//                 text: explanationProcessed.english,
//                 size: 24,
//               }),
//             ],
//             spacing: { after: 100 },
//           })
//         );
//       }

//       if (explanationProcessed.hindi) {
//         paragraphs.push(
//           new Paragraph({
//             children: [
//               new TextRun({
//                 text: explanationProcessed.hindi,
//                 size: 24,
//               }),
//             ],
//             spacing: { after: 100 },
//           })
//         );
//       }

//       if (containsImage(question.description)) {
//         const solImages = extractImageUrls(question.description);
//         solImages.forEach((url, idx) => {
//           paragraphs.push(
//             new Paragraph({
//               children: [
//                 new TextRun({
//                   text: `[Explanation Image ${idx + 1}: ${url}]`,
//                   size: 20,
//                   color: "0000FF",
//                   italics: true,
//                 }),
//               ],
//               spacing: { before: 50, after: 50 },
//             })
//           );
//         });
//       }
//     }

//     // Spacing between questions
//     paragraphs.push(
//       new Paragraph({
//         text: "",
//         spacing: { before: 300, after: 300 },
//       })
//     );
//   });

//   return new Document({
//     sections: [
//       {
//         properties: {
//           page: {
//             margin: {
//               top: 1440,
//               right: 1440,
//               bottom: 1440,
//               left: 1440,
//             },
//           },
//         },
//         children: paragraphs,
//       },
//     ],
//   });
// }

// // Export helper
// export async function saveWordDocument(
//   doc: Document,
//   filename: string
// ): Promise<Blob> {
//   const blob = await Packer.toBlob(doc);
//   return blob;
// }